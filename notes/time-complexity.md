# 時間計算量・空間計算量 チートシート

## ⏱️ 時間計算量の基本

### よく見る計算量（速い順）

| 記法 | 名前 | 例 | N=10⁶での実行時間目安 |
|------|------|----|-----------------------|
| O(1) | 定数時間 | 配列のランダムアクセス | 1回 |
| O(log N) | 対数時間 | 二分探索 | 20回 |
| O(N) | 線形時間 | 配列の全要素走査 | 10⁶回 |
| O(N log N) | 線形対数時間 | マージソート | 2×10⁷回 |
| O(N²) | 二次時間 | バブルソート | 10¹²回 |
| O(2ᴺ) | 指数時間 | 全組み合わせ | 2^(10⁶)回 |
| O(N!) | 階乗時間 | 全順列 | (10⁶)!回 |

### 💡 実用的な目安
- **N ≤ 10**: O(N!) も可能
- **N ≤ 20**: O(2ᴺ) が限界
- **N ≤ 500**: O(N³) が限界
- **N ≤ 5000**: O(N²) が限界
- **N ≤ 10⁶**: O(N log N) が限界
- **N ≤ 10⁸**: O(N) が限界

## 📊 データ構造別の計算量

### 配列 (Array)
| 操作 | 時間計算量 | 備考 |
|------|------------|------|
| アクセス | O(1) | インデックス指定 |
| 探索 | O(N) | 線形探索 |
| 挿入 | O(N) | 末尾以外への挿入 |
| 削除 | O(N) | 末尾以外からの削除 |

### 連結リスト (Linked List)
| 操作 | 時間計算量 | 備考 |
|------|------------|------|
| アクセス | O(N) | 順次アクセス |
| 探索 | O(N) | 線形探索 |
| 挿入 | O(1) | ポインタがある位置 |
| 削除 | O(1) | ポインタがある位置 |

### スタック/キュー (Stack/Queue)
| 操作 | 時間計算量 | 備考 |
|------|------------|------|
| Push/Enqueue | O(1) | 要素の追加 |
| Pop/Dequeue | O(1) | 要素の取り出し |
| Peek/Front | O(1) | 先頭要素の参照 |

### ハッシュテーブル (Hash Table)
| 操作 | 平均 | 最悪 | 備考 |
|------|------|------|------|
| 探索 | O(1) | O(N) | 衝突が多い場合 |
| 挿入 | O(1) | O(N) | 衝突が多い場合 |
| 削除 | O(1) | O(N) | 衝突が多い場合 |

### 二分探索木 (Binary Search Tree)
| 操作 | 平均 | 最悪 | 備考 |
|------|------|------|------|
| 探索 | O(log N) | O(N) | 偏った木 |
| 挿入 | O(log N) | O(N) | 偏った木 |
| 削除 | O(log N) | O(N) | 偏った木 |

### ヒープ (Heap)
| 操作 | 時間計算量 | 備考 |
|------|------------|------|
| 最小/最大値取得 | O(1) | ルート要素 |
| 挿入 | O(log N) | ヒープ化 |
| 削除 | O(log N) | ヒープ化 |
| 構築 | O(N) | 配列からヒープ構築 |

## 🔍 アルゴリズム別の計算量

### ソートアルゴリズム
| アルゴリズム | 平均 | 最悪 | 最良 | 空間 | 安定性 |
|-------------|------|------|------|------|--------|
| バブルソート | O(N²) | O(N²) | O(N) | O(1) | 安定 |
| 選択ソート | O(N²) | O(N²) | O(N²) | O(1) | 不安定 |
| 挿入ソート | O(N²) | O(N²) | O(N) | O(1) | 安定 |
| マージソート | O(N log N) | O(N log N) | O(N log N) | O(N) | 安定 |
| クイックソート | O(N log N) | O(N²) | O(N log N) | O(log N) | 不安定 |
| ヒープソート | O(N log N) | O(N log N) | O(N log N) | O(1) | 不安定 |
| 基数ソート | O(d×N) | O(d×N) | O(d×N) | O(N+k) | 安定 |

### 探索アルゴリズム
| アルゴリズム | 時間計算量 | 空間計算量 | 備考 |
|-------------|------------|------------|------|
| 線形探索 | O(N) | O(1) | 未ソート配列 |
| 二分探索 | O(log N) | O(1) | ソート済み配列 |
| DFS | O(V + E) | O(V) | グラフ探索 |
| BFS | O(V + E) | O(V) | グラフ探索 |

### 文字列アルゴリズム
| アルゴリズム | 時間計算量 | 備考 |
|-------------|------------|------|
| 単純探索 | O(N×M) | N:テキスト長, M:パターン長 |
| KMP | O(N + M) | 前処理あり |
| Rabin-Karp | O(N + M) | 平均的な場合 |

## 🎯 LeetCode でよく使う計算量パターン

### Two Pointers
```python
# O(N) 時間, O(1) 空間
while left < right:
    # 処理
    left += 1
    # または
    right -= 1
```

### Sliding Window
```python
# O(N) 時間, O(k) 空間 (kはウィンドウサイズ)
for i in range(len(arr)):
    # ウィンドウの更新
    # 条件チェック
```

### Binary Search
```python
# O(log N) 時間, O(1) 空間
while left <= right:
    mid = (left + right) // 2
    # 二分探索の条件分岐
```

### DFS/BFS
```python
# O(V + E) 時間, O(V) 空間
# V: 頂点数, E: 辺数
def dfs(node):
    # 再帰または反復で実装
```

### Dynamic Programming
```python
# 1次元DP: O(N) 時間, O(N) 空間
dp = [0] * n
for i in range(1, n):
    dp[i] = # 状態遷移

# 2次元DP: O(N×M) 時間, O(N×M) 空間
dp = [[0] * m for _ in range(n)]
for i in range(n):
    for j in range(m):
        dp[i][j] = # 状態遷移
```

## 📝 計算量分析のコツ

### 1. ループの分析
- **単一ループ**: O(N)
- **ネストしたループ**: O(N²), O(N³), ...
- **二分探索型**: O(log N)

### 2. 再帰の分析
- **Master定理**を使用
- **再帰木**を描いて分析

### 3. 空間計算量の注意点
- **再帰の深さ**: O(深さ)
- **補助データ構造**: ハッシュテーブル、配列など
- **入力データのコピー**: 必要に応じて

### 4. よくある間違い
- ループ内でのslice操作: `arr[i:j]` は O(j-i)
- 文字列の結合: `s += char` は Python では O(N²)
- リストの挿入: `list.insert(0, x)` は O(N)

---

## ⚡ 高速化のテクニック

1. **メモ化**: 重複計算の削減
2. **前計算**: 累積和、前綴和など
3. **データ構造の選択**: 適切なデータ構造を使用
4. **bit演算**: 高速な演算
5. **空間と時間のトレードオフ**: メモリを使って時間を短縮

問題を解く際は、まず素朴な解法を考え、その後計算量を分析して最適化を検討しましょう。
